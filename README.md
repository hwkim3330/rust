아래는 대표적인 **정렬 알고리즘**들을 **시간복잡도, 공간복잡도, 안정성, 특징**까지 포함하여 정리한 **비교 표**입니다.

---

## ✅ 정렬 알고리즘 비교표

| 알고리즘        | 최선 시간복잡도   | 평균 시간복잡도   | 최악 시간복잡도   | 공간복잡도    | 안정 정렬 | 주요 특징                   |
| ----------- | ---------- | ---------- | ---------- | -------- | ----- | ----------------------- |
| **삽입정렬**    | O(n)       | O(n²)      | O(n²)      | O(1)     | ✅     | 거의 정렬된 경우 매우 빠름         |
| **선택정렬**    | O(n²)      | O(n²)      | O(n²)      | O(1)     | ❌     | 비교 횟수는 고정, 자리 바꿈 최소     |
| **버블정렬**    | O(n)       | O(n²)      | O(n²)      | O(1)     | ✅     | 단순하지만 비효율적              |
| **병합정렬**    | O(n log n) | O(n log n) | O(n log n) | O(n)     | ✅     | 안정적, 외부 정렬에 적합          |
| **퀵정렬**     | O(n log n) | O(n log n) | O(n²)      | O(log n) | ❌     | 평균적으로 매우 빠름, 내부 정렬      |
| **힙정렬**     | O(n log n) | O(n log n) | O(n log n) | O(1)     | ❌     | 메모리 효율적, 불안정 정렬         |
| **계수정렬**    | O(n + k)   | O(n + k)   | O(n + k)   | O(k)     | ✅     | 숫자 범위가 작을 때 매우 빠름       |
| **기수정렬**    | O(n·k)     | O(n·k)     | O(n·k)     | O(n + k) | ✅     | 자릿수 기반, 문자열/숫자 정렬에 적합   |
| **버킷정렬**    | O(n + k)   | O(n + k)   | O(n²)      | O(n + k) | ✅     | 실수, 균등 분포된 데이터에 적합      |
| **TimSort** | O(n)       | O(n log n) | O(n log n) | O(n)     | ✅     | 삽입정렬+병합정렬, Python 기본 정렬 |

> 💡 `k`는 값의 범위 또는 자릿수입니다 (계수/기수/버킷정렬에서 사용).

---

## ✅ 용어 정리

| 용어        | 의미                        |
| --------- | ------------------------- |
| **시간복잡도** | 입력 크기 `n`에 따른 처리 시간의 증가   |
| **공간복잡도** | 정렬 중 추가로 필요한 메모리 양        |
| **안정 정렬** | 같은 값을 가진 원소의 상대 순서가 유지되는가 |

---

## ✅ 정렬 알고리즘 선택 가이드

| 상황          | 추천 알고리즘 | 이유                     |
| ----------- | ------- | ---------------------- |
| 데이터가 거의 정렬됨 | 삽입정렬    | O(n)에 근접, 간단함          |
| 대용량 외부 정렬   | 병합정렬    | 안정성 + 분할 정복, 디스크 정렬 적합 |
| 평균적으로 빠른 정렬 | 퀵정렬     | 내부 정렬 중 가장 빠름 (단, 불안정) |
| 메모리 사용 최소화  | 힙정렬     | O(1) 공간 사용             |
| 값의 범위가 제한적  | 계수/기수정렬 | O(n) 가능, 매우 빠름         |
| 실무/라이브러리 수준 | TimSort | 다양한 상황에서 우수한 성능        |

---
 
---

## ☁️ 온라인에서 바로 실행해보기

### ▶ GitHub Codespaces (브라우저 VS Code 환경)

[![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://github.com/codespaces/new?hide_repo_select=true&repo=hwkim3330%2Frust&ref=main)

> 깃허브 계정만 있으면 별도 설치 없이 브라우저에서 `cargo run` 가능

---

### ▶ Replit (웹 기반 Rust IDE)

[![Run on Replit](https://replit.com/badge/github/hwkim3330/rust)](https://replit.com/github/hwkim3330/rust)

> 웹에서 바로 `cargo run` 가능하며 수정·저장도 가능 (Replit 계정 필요)

# Rust Playground 🦀

Rust를 처음 배울 때 바로 **`cargo run`** 으로 실행(=자동 빌드)하며
핵심 개념을 익힐 수 있는 초소형 예제 모음입니다.

> `cargo run` → *필요하면* 자동으로 빌드 후 즉시 실행  
> 별도 `cargo build` 단계 없이 “바로 런”이 가능합니다.

---

## 📂 프로젝트 구조

```

rust/
├─ src/
│  ├─ main.rs                 # 안내 메뉴(선택)
│  └─ bin/
│     ├─ calculator.rs        # CLI 계산기 예제
│     └─ insertion\_sort.rs    # 삽입정렬 데모
├─ Cargo.toml
└─ README.md                  # ← 바로 이 파일

````

- `src/bin/*.rs` **각각이 독립 실행파일**(바이너리)  
  → 별도 모듈/라이브러리 참조 없음, 복사·실험 간편
- `src/main.rs` 는 단순 안내; 없어도 무방

---

## 🚀 빠른 실행

| 목적 | 명령 |
|------|------|
| **메뉴** (optional)            | `cargo run` |
| **CLI 계산기**                 | `cargo run --bin calculator` |
| **삽입정렬(Insertion Sort)**   | `cargo run --bin insertion_sort` |
| **최적화 빌드 + 실행**         | `cargo run --release --bin calculator` |

---

## 📝 코드 설명

### 1. `calculator.rs`

| 포인트 | 코드 스니펫 | 설명 |
|--------|-------------|------|
| 입력 읽기 | `read_line()` | `stdin().read_line()` 뒤 `trim()` 으로 공백 제거 |
| 숫자 파싱 | `read_num()` | `String::parse::<f64>()` ➜ 실패 시 재입력 루프 |
| 연산자 검증 | `read_op()` | `match` 로 `+ - * /` 만 허용 |
| 계산 실행 | `calc()` | 0으로 나눌 때 `None` 반환 → `match` 로 에러 메시지 |
| 반복 | `loop { ... }` | 사용자가 `y` 입력 시만 계속 |

> **학습 포인트**  
> - `Result`, `Option`, `match` 로 안전한 입력 처리  
> - `String` vs `&str` 소유권, `to_lowercase()` 메서드 체인

### 2. `insertion_sort.rs`

| 포인트 | 코드 | 설명 |
|--------|------|------|
| 핵심 루프 | `for i in 1..v.len()` | 1번째부터 끝까지 key 선택 |
| 앞쪽 이동 | `while j>0 && v[j-1]>key` | 더 큰 값 뒤로 한 칸씩 쉬프트 |
| 삽입 | `v[j] = key` | 적절 위치에 key 삽입 |
| 제자리 정렬 | 추가 메모리 O(1) | `Vec` 그대로 수정 |

> **학습 포인트**  
> - 배열 슬라이스 `&mut [i32]` 사용으로 **제자리(in-place) 정렬**  
> - 루프 변수 `i, j` 로 구현하는 **고전적 삽입정렬**

---

## 💡 Rust 개념 한눈에

| 개념 | 코드에서 보는 위치 | 의미 |
|------|-------------------|------|
| `loop { ... }`      | 입력 재시도 | 무한 루프, 내부 `break` 로 탈출 |
| `match`             | 연산자·에러 처리 | 패턴 매칭, C의 switch 보다 강력 |
| `Option<T>` / `None`| `calc()`   | 값 부재 표현, null 안전 대체 |
| `Result<T,_>`       | `read_line`| I/O 성공·실패 구분 |
| 가변 참조 `&mut`    | 정렬함수   | 슬라이스를 **수정** 가능하게 전달 |

---

## 🛠️ 커스텀 예제 추가

1. `src/bin/my_demo.rs` 파일 생성  
2. `fn main() { /* … */ }` 작성  
3. 실행:  
   ```bash
   cargo run --bin my_demo
````

---

## 📜 라이선스

MIT License © 2025 [hwkim3330](https://github.com/hwkim3330)

```

> 위 내용을 `README.md`에 그대로 붙여 넣으면 **프로젝트 소개 + 코드 요약 + 실행 방법**이 모두 포함된 깔끔한 리드미가 완성됩니다. 필요에 따라 테스트, 기여 가이드 등을 추가해도 좋습니다. 😉
```
